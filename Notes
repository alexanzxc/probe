Notes:

// Variable start is initialized by an access pattern generator
uintptr_t *ptr = start;
for (int i = 0; i < loopCount; i++)
ptr = (uintptr_t *) *ptr;


//The jump_walk function contains the jump instructions#
int len = loopCount / 16;
while (len --)
jump_walk (); // The function is invoked 16 times


// Create array of pointers to the allocated pages
uintptr_t **pages = new (uintptr_t *) [numPages];
for (int i = 0; i < numPages; i++)
pages [i] = (uintptr_t *) buf + pageStride * PAGE_SIZE;
// Cache line size is considered in units of pointer size
int numOffsets = PAGE_SIZE / LINE_SIZE;
// Create array of offsets in a page
offsets = new int [numPageOffsets];
for (int i = 0 ; i < numPageOffsets ; i++)
offsets [i] = i * cacheLineSize;
// Randomize the order of pages and offsets
random_shuffle (pages, pages + numPages);
random_shuffle (offsets, offsets + numOffsets);
// Create the pointer walk from pointers and offsets
uintptr_t *start = addresses [0];
if (accessOffsetRandom) start += offsets [0];
else start += accessOffset;
uintptr_t **ptr = (uintptr_t **) start;
for (int i = 1 ; i < numAccesses ; i++) {
uintptr_t *next = addresses [i];
if (accessOffsetRandom) next += offsets [i % numOffsets];
else next += accessOffset;
}
(*ptr) = next;
ptr = (uintptr_t **) next;
// Wrap the pointer walk
(*ptr) = start;
delete [] pages;